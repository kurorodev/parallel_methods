<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Лабораторная работа №1 - Умножение матриц</title>
    <meta charset="UTF-8">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 1200px; margin: 0 auto; padding: 20px; }
        
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background: #f4f4f4; border-radius: 8px; }
        .header h1 { color: #2c3e50; margin-bottom: 10px; }
        
        .input-section { background: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .input-group { margin-bottom: 15px; display: flex; align-items: center; flex-wrap: wrap; gap: 10px; }
        .input-group label { font-weight: bold; min-width: 120px; }
        .input-group input { padding: 8px 12px; border: 2px solid #ddd; border-radius: 4px; width: 80px; text-align: center; }
        .input-group input:focus { border-color: #3498db; outline: none; }
        .input-group input.error { border-color: #e74c3c; }
        
        .buttons { display: flex; gap: 15px; margin: 20px 0; flex-wrap: wrap; }
        button { padding: 12px 25px; border: none; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s; }
        button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .btn-calculate { background: #3498db; color: white; }
        .btn-test { background: #2ecc71; color: white; }
        .btn-clear { background: #e74c3c; color: white; }
        
        .results { background: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .results h3 { color: #2c3e50; margin-bottom: 15px; border-bottom: 2px solid #3498db; padding-bottom: 8px; }
        
        table { width: 100%; border-collapse: collapse; margin: 15px 0; background: white; }
        th, td { padding: 12px; text-align: center; border: 1px solid #ddd; }
        th { background: #f8f9fa; font-weight: bold; color: #2c3e50; }
        tr:nth-child(even) { background: #f8f9fa; }
        tr:hover { background: #e3f2fd; }
        
        .chart-container { margin: 30px 0; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #chart { width: 100%; height: 400px; }
        
        .error-message { color: #e74c3c; padding: 10px; background: #fdf2f2; border: 1px solid #e74c3c; border-radius: 4px; margin: 10px 0; }
        .success-message { color: #2ecc71; padding: 10px; background: #f2fdf2; border: 1px solid #2ecc71; border-radius: 4px; margin: 10px 0; }
        
        .loading { display: none; text-align: center; padding: 20px; }
        .loading.spinner { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        @media (max-width: 768px) {
            .input-group { flex-direction: column; align-items: flex-start; }
            .input-group input { width: 100px; }
            .buttons { flex-direction: column; }
            button { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Лабораторная работа №1</h1>
        <h2>Параллельное и последовательное умножение матриц</h2>
        <p>Самарский Государственный Технический Университет</p>
    </div>

    <div class="input-section">
        <h3>Параметры матриц</h3>
        
        <div class="input-group">
            <label for="rowsA">Матрица A - Строки:</label>
            <input type="number" id="rowsA" min="1" max="1000" value="100" oninput="validateNumber(this)">
            <label for="colsA">Столбцы:</label>
            <input type="number" id="colsA" min="1" max="1000" value="100" oninput="validateNumber(this)">
        </div>
        
        <div class="input-group">
            <label for="rowsB">Матрица B - Строки:</label>
            <input type="number" id="rowsB" min="1" max="1000" value="100" oninput="validateNumber(this)">
            <label for="colsB">Столбцы:</label>
            <input type="number" id="colsB" min="1" max="1000" value="100" oninput="validateNumber(this)">
        </div>
        
        <div class="input-group">
            <label for="threads">Количество потоков:</label>
            <input type="number" id="threads" min="1" max="32" value="4" oninput="validateNumber(this)">
        </div>

        <div class="buttons">
            <button class="btn-calculate" onclick="calculate()">Вычислить</button>
            <button class="btn-test" onclick="runTests()">Запустить тесты</button>
            <button class="btn-clear" onclick="clearResults()">Очистить результаты</button>
        </div>
    </div>

    <div class="loading">
        <div class="spinner"></div>
        <p>Выполнение вычислений...</p>
    </div>

    <div class="results">
        <h3>Результаты вычислений</h3>
        <div id="errorMessage" class="error-message" style="display: none;"></div>
        <div id="successMessage" class="success-message" style="display: none;"></div>
        
        <div id="singleResult">
            <table id="resultTable">
                <thead>
                    <tr>
                        <th>Метод</th>
                        <th>Время (секунды)</th>
                        <th>Размер матрицы</th>
                        <th>Потоки</th>
                        <th>Ускорение</th>
                        <th>Корректность</th>
                    </tr>
                </thead>
                <tbody id="resultTableBody"></tbody>
            </table>
        </div>

        <div id="testResults" style="display: none;">
            <h4>Результаты тестирования</h4>
            <table id="testTable">
                <thead>
                    <tr>
                        <th>Размер</th>
                        <th>Посл. время</th>
                        <th>Пар. время</th>
                        <th>Ускорение</th>
                        <th>Потоки</th>
                    </tr>
                </thead>
                <tbody id="testTableBody"></tbody>
            </table>
        </div>
    </div>

    <div class="chart-container">
        <h3>График зависимости времени от размера матрицы</h3>
        <canvas id="chart"></canvas>
    </div>

    <script>
        const SERVER_URL = 'http://localhost:8080';
        let testData = [];
        let chart = null;

        function validateNumber(input) {
            const value = parseInt(input.value);
            const min = parseInt(input.min);
            const max = parseInt(input.max);
            
            if (isNaN(value) || value < min) {
                input.value = min;
                input.classList.add('error');
            } else if (value > max) {
                input.value = max;
                input.classList.add('error');
            } else {
                input.classList.remove('error');
            }
            
            // Проверка совместимости матриц
            const colsA = parseInt(document.getElementById('colsA').value);
            const rowsB = parseInt(document.getElementById('rowsB').value);
            
            if (colsA !== rowsB) {
                showError('Размеры матриц несовместимы для умножения!');
            } else {
                hideError();
            }
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        function showSuccess(message) {
            const successDiv = document.getElementById('successMessage');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            setTimeout(() => successDiv.style.display = 'none', 3000);
        }

        function showLoading() {
            document.querySelector('.loading').style.display = 'block';
        }

        function hideLoading() {
            document.querySelector('.loading').style.display = 'none';
        }

        async function calculate() {
            const rowsA = parseInt(document.getElementById('rowsA').value);
            const colsA = parseInt(document.getElementById('colsA').value);
            const rowsB = parseInt(document.getElementById('rowsB').value);
            const colsB = parseInt(document.getElementById('colsB').value);
            const threads = parseInt(document.getElementById('threads').value);

            if (colsA !== rowsB) {
                showError('Ошибка: Количество столбцов матрицы A должно равняться количеству строк матрицы B');
                return;
            }

            showLoading();
            hideError();

            try {
                const response = await fetch(SERVER_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        rowsA: rowsA,
                        colsA: colsA,
                        rowsB: rowsB,
                        colsB: colsB,
                        threads: threads
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                displayResult(data);
                showSuccess('Вычисления успешно завершены!');

            } catch (error) {
                showError('Ошибка соединения с сервером: ' + error.message);
                console.error('Error:', error);
            } finally {
                hideLoading();
            }
        }

        function displayResult(data) {
            const tableBody = document.getElementById('resultTableBody');
            tableBody.innerHTML = '';

            const rows = [
                {
                    method: 'Последовательный',
                    time: data.sequential_time.toFixed(6),
                    size: `${data.rows}x${data.cols}`,
                    threads: '1',
                    speedup: '1.00x',
                    correct: data.correct ? '✓' : '✗'
                },
                {
                    method: 'Параллельный',
                    time: data.parallel_time.toFixed(6),
                    size: `${data.rows}x${data.cols}`,
                    threads: data.threads,
                    speedup: `${(data.sequential_time / data.parallel_time).toFixed(2)}x`,
                    correct: data.correct ? '✓' : '✗'
                }
            ];

            rows.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${row.method}</td>
                    <td>${row.time}</td>
                    <td>${row.size}</td>
                    <td>${row.threads}</td>
                    <td>${row.speedup}</td>
                    <td style="color: ${row.correct === '✓' ? 'green' : 'red'}">${row.correct}</td>
                `;
                tableBody.appendChild(tr);
            });

            // Сохраняем для графика
            testData.push({
                size: data.rows,
                sequential: data.sequential_time,
                parallel: data.parallel_time,
                speedup: data.sequential_time / data.parallel_time
            });

            updateChart();
        }

        async function runTests() {
            const sizes = [50, 100, 200, 300, 400];
            const threads = parseInt(document.getElementById('threads').value);
            testData = [];

            showLoading();
            document.getElementById('testResults').style.display = 'block';
            const testTableBody = document.getElementById('testTableBody');
            testTableBody.innerHTML = '';

            for (const size of sizes) {
                try {
                    const response = await fetch(SERVER_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            rowsA: size,
                            colsA: size,
                            rowsB: size,
                            colsB: size,
                            threads: threads
                        })
                    });

                    const data = await response.json();

                    // Добавляем в таблицу тестов
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td>${size}x${size}</td>
                        <td>${data.sequential_time.toFixed(4)}</td>
                        <td>${data.parallel_time.toFixed(4)}</td>
                        <td>${(data.sequential_time / data.parallel_time).toFixed(2)}x</td>
                        <td>${threads}</td>
                    `;
                    testTableBody.appendChild(tr);

                    // Сохраняем для графика
                    testData.push({
                        size: size,
                        sequential: data.sequential_time,
                        parallel: data.parallel_time,
                        speedup: data.sequential_time / data.parallel_time
                    });

                } catch (error) {
                    console.error(`Error testing size ${size}:`, error);
                }
            }

            updateChart();
            hideLoading();
            showSuccess('Тестирование завершено!');
        }

        function updateChart() {
            const ctx = document.getElementById('chart').getContext('2d');
            
            if (chart) {
                chart.destroy();
            }

            // Простая реализация графика без внешних библиотек
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            if (testData.length === 0) return;

            const padding = 40;
            const width = ctx.canvas.width - padding * 2;
            const height = ctx.canvas.height - padding * 2;

            // Находим максимальные значения для масштабирования
            const maxSize = Math.max(...testData.map(d => d.size));
            const maxTime = Math.max(...testData.map(d => Math.max(d.sequential, d.parallel)));

            // Оси
            ctx.beginPath();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height + padding);
            ctx.lineTo(width + padding, height + padding);
            ctx.stroke();

            // Подписи осей
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.fillText('Время (сек)', padding - 30, padding - 10);
            ctx.fillText('Размер матрицы', width + padding - 50, height + padding + 20);

            // Рисуем графики
            drawLine(ctx, testData, 'sequential', 'red', padding, width, height, maxSize, maxTime);
            drawLine(ctx, testData, 'parallel', 'blue', padding, width, height, maxSize, maxTime);

            // Легенда
            ctx.fillStyle = 'red';
            ctx.fillRect(width + padding - 100, padding, 20, 3);
            ctx.fillText('Последовательный', width + padding - 75, padding + 10);
            
            ctx.fillStyle = 'blue';
            ctx.fillRect(width + padding - 100, padding + 20, 20, 3);
            ctx.fillText('Параллельный', width + padding - 75, padding + 30);
        }

        function drawLine(ctx, data, type, color, padding, width, height, maxSize, maxTime) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            data.forEach((d, i) => {
                const x = padding + (d.size / maxSize) * width;
                const y = padding + height - (d[type] / maxTime) * height;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();
        }

        function clearResults() {
            document.getElementById('resultTableBody').innerHTML = '';
            document.getElementById('testTableBody').innerHTML = '';
            document.getElementById('testResults').style.display = 'none';
            testData = [];
            
            const ctx = document.getElementById('chart').getContext('2d');
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            hideError();
        }

        // Инициализация при загрузке
        document.addEventListener('DOMContentLoaded', function() {
            // Проверяем доступность сервера
            fetch(SERVER_URL, { method: 'OPTIONS' })
                .then(response => {
                    if (!response.ok) {
                        showError('Сервер не доступен. Запустите C сервер на порту 8080');
                    }
                })
                .catch(() => {
                    showError('Сервер не доступен. Запустите C сервер на порту 8080');
                });
        });
    </script>
</body>
</html>
